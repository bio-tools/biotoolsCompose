/*                                                                                                    */
/* rt - retention time (predictor) v4.0.20160301                                                      */
/*                                                                                                    */
/* (c) Magnus Palmblad, Division of Ion Physics, Uppsala University, 2002-                            */
/*                                                                                                    */
/*                                                                                                    */
/* Version 4.0 of rt now also accepts pepXML input instead of just tab-delimited files, recognizes    */
/* the input format automatically and can generate output (retention coefficients) either as a tab-   */
/* delimited text file or an XML structure. Known bugs: This version does not extract modifications   */
/* from the pepXML files and only works with the pepXML files generated from PeptideProphet.          */
/* The program does not perform detailed checks on the input, i.e. peptide lengths and syntax errors. */
/*                                                                                                    */
/* Usage: rt -i <training set in tab delimited or pepXML format> [-f <tab>|<XML> output format)]>     */
/*                                                                                                    */
/* compile with gcc -o rt rt3.c -lgsl -lgslcblas -lpepXML -LpepXMLLib                                 */
/*                                                                                                    */ 
/*                                                                                                    */
/* The mzIdentML support is extremely "quick-and-dirty" but work with tested idconvert-ed pepXML      */
/*                                                                                                    */

#include <stdio.h>
#include <stdlib.h>  
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <gsl/gsl_math.h>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_multifit.h>
#include "pepXMLLib/pepXMLReader.h"

#define AMINO_ACIDS "ARNDCEQGHILKMFPSTWYVmsty"
#define MAX_PEPTIDE_LENGTH 100

int main(int argc, char *argv[]) 
{
  char line[250];      
  char infile[85], outfile[85]; /* for reading input and writing output */
  char slask[85];
  
  typedef struct {
    char sequence[MAX_PEPTIDE_LENGTH];
    int composition[24];
    float retention;
  } training_set_type;
  
  training_set_type *training_set;
  
  char output[256];
  char output_format[256];
  char input_format[20];
  
  char *p, q[100], **PEP;
  
  pmsms_pipeline_analysis pepXML_file;
  pdelegate_list dlgl;
  pdelegate_type dlg; 

  FILE *inp, *outp;
  
  int a, b, i, j, k, l, m, n, seqlen, n_training,length;
  double xi, yi, ei, chisq;
  gsl_matrix *X, *cov;
  gsl_vector *y, *w, *c; 
  gsl_multifit_linear_workspace *work;
  
  
  /* parsing command line parameters */
  
  if ((argc<2)||(argc>5))
    {
      printf("usage: rt -i <training set in tab delimited or PeptideProphet pepXML format> [-f <tab>|<XML> output format)] (type rt --help for more information\n");
      return -1;
    }
  
  if( (strcmp(argv[1],"--help")==0) || (strcmp(argv[1],"-help")==0) || (strcmp(argv[1],"-h")==0) ) /* want help? */
    {
      printf("rt - (c) Magnus Palmblad 2002-2012\n\nusage: rt -i <training set in tab-delimited or pepXML format (after PeptideProphet)> [-f <tab>|<XML> output format)]\nrt trains a linear model for predicting retention time, or in fact any additive property as function of amino acid composition. The input should either be a tab-delimited text file with peptide sequences in the first column and a numerical value (retention time) in the second column, or a pepXML file generated by PeptideProphet in the Trans-Proteomic Pipeline. For more information, see http://www.ms-utils.org/rt or e-mail magnus.palmblad@gmail.com\n");
      return 0;
    }
  
  for(i=1;i<argc;i++) {
    if( (argv[i][0]=='-') && (argv[i][1]=='i') ) strcpy(infile,&argv[strlen(argv[i])>2?i:i+1][strlen(argv[i])>2?2:0]);
    if( (argv[i][0]=='-') && (argv[i][1]=='f') ) strcpy(output_format,&argv[strlen(argv[i])>2?i:i+1][strlen(argv[i])>2?2:0]);
  }
  
  if( (toupper(output_format[0])!='T') && (toupper(output_format[0])!='X') && (toupper(output_format[0])!='C') ) {
    printf("usage: rt -i <training set in tab delimited or pepXML format> [-f <tab>|<XML> output format)]\n");
    return -1;
  }

  strcpy(input_format,"tab"); /* default to tab-delimited input */


  /* reading training set file */

  //printf("checking input format and scanning training set in file %s...", infile); fflush(stdout);
  n=0;
  if ((inp = fopen(infile, "r"))==NULL) {printf("error opening training set file\n");return -1;}
  fgets(line, 250, inp);
  if(line[0]=='<') {strcpy(input_format,"pepXML"); n++;}
  fgets(line, 250, inp);
  while(line[i]) {line[i]=toupper(line[i]); i++;}
  if(strstr(line,"MZIDENTML")!=NULL) {strcpy(input_format,"mzIdentML"); n++;}

  while (fgets(line, 250, inp) != NULL) n++;

  PEP=(char**)malloc(sizeof(char*)*n);
  for(i=0;i<10000;i++) PEP[i]=(char*)malloc(sizeof(char)*200);
  
  if(strcmp(input_format,"tab")==0)
    {
      n_training=n;
  
      // printf("done\nallocating memory for %i peptides in training set...", n_training); fflush(stdout);
      training_set=(training_set_type*)malloc(sizeof(training_set_type)*n_training);
      
      // printf("done\nreading training set in tab delimited format (peptide tab retention time) from file %s...", infile); fflush(stdout);
      if ((inp = fopen(infile, "r"))==NULL) {printf("error opening training set file\n");return -1;}
      n=0; 
      
      while (fgets(line, 250, inp) != NULL)
	{
	  sscanf(line,"%s\t%f",training_set[n].sequence,&(training_set[n].retention));
	  n++;
	}
      n_training=n;
      fclose(inp);
      // printf("done\n");
    }
  

  if(strcmp(input_format,"pepXML")==0)
    {
      // printf("done\nscanning training set in pepXML format from file %s...", infile); fflush(stdout);
      n=0;
      pepXML_file = read_pepxml_file(infile, 0, 0, NULL);
      for (i=0; i<pepXML_file->run_summary_count; i++) {
	for (j=0; j<pepXML_file->run_summary_array[i].spectrum_query_count; j++) n++;
      }
      n_training=n;

      // printf("done\nallocating memory for %i peptides in training set...", n_training); fflush(stdout);
      training_set=(training_set_type*)malloc(sizeof(training_set_type)*n_training);
      
      n=0;
      // printf("reading training set in pepXML format from file %s...", infile); fflush(stdout);
      for (i=0; i<pepXML_file->run_summary_count; i++) {
	for (j=0; j<pepXML_file->run_summary_array[i].spectrum_query_count; j++) {
	  strcpy(training_set[n].sequence, pepXML_file->run_summary_array[i].spectrum_query_array[j].search_result_array[0].search_hit_array[0].peptide);
	  training_set[n].retention = pepXML_file->run_summary_array[i].spectrum_query_array[j].retention_time_sec;
	  n++;
	}
      }
    }

  if(strcmp(input_format,"mzIdentML")==0)
    {
      //printf("done\nscanning training set in mzIdentML format from file %s...", infile); fflush(stdout);
      n=0;
      if ((inp = fopen(infile, "r"))==NULL) {printf("error opening training set file\n");return -1;}
      while (fgets(line, 250, inp) != NULL)
	{
	  if(strstr(line,"PeptideEvidence")!=NULL) break;
	  if(strstr(line,"<Peptide id")!=NULL)
	    {
	      //PEP[a]=(char*)malloc(sizeof(char)*strlen(q));
	      p=strtok(line,"\""); p=strtok('\0',"\"");
	      a=atoi(p+4);
	      //printf("\n%i = ",a); fflush(stdout);
	      p=strtok('\0',"\"");
	      if(strstr(p,"<PeptideSequence>")!=NULL)
		{
		  p=strchr(p+10,'>')+1;
		  i=strspn(p,AMINO_ACIDS);
		  strncpy(q,p,i); q[i]='\0';
		  // printf("PEP_%i=%s\n",a,q); fflush(stdout);
		  strcpy(PEP[a],q);
		}
	      n++;
	    }
	}

      n_training=n;

      // printf("done\nallocating memory for %i peptides in training set...", n_training); fflush(stdout);
      training_set=(training_set_type*)malloc(sizeof(training_set_type)*n_training*10);

      n=0;
      while (fgets(line, 250, inp) != NULL)
	{
	  if(strstr(line,"peptide_ref")!=NULL)
	    {
	      p=strstr(line,"peptide_ref");
	      a=atoi(strtok(p+17,"\""));
	    }
	  if(strstr(line,"name=\"scan start time\" value")!=NULL)
	    {
	      p=strstr(line,"name=\"scan start time\" value");
	      i=strcspn(p+31,"\"");
	      strncpy(q,p+30,i); q[i]='\0';
	      // if(strlen(PEP[a])>6) {printf("%i, %s, %s\n",a,PEP[a],q); fflush(stdout);}
	      if(strlen(PEP[a])>6) {strcpy(training_set[n].sequence,PEP[a]); training_set[n].retention=atof(q); n++;}
	    }
	}
    }

  n_training=n;
  //return 0;
     
  /* allocating memory for training */
      
  X=gsl_matrix_alloc(n_training,25); /* 20 normal amino acids, pS, pT, pY, oxidized M and V0 */
  y=gsl_vector_alloc(n_training);
  w=gsl_vector_alloc(n_training);
  c=gsl_vector_alloc(25);
  cov=gsl_matrix_alloc(25,25);
 
  for(i=0;i<25;i++) gsl_vector_set(c,i,1.0);
 
  
  /* calculate training set X matrix (amino acid composition for each peptide in training set) */
  
  for(n=0;n<n_training;n++)
    {
      gsl_vector_set(y,n,training_set[n].retention);
      gsl_vector_set(w,n,0.36);
      
      for(i=0;i<24;i++) training_set[n].composition[i]=0;
      {
	for(i=0;i<strlen(training_set[n].sequence);i++)
	  {
	    a=24-strlen(strchr(AMINO_ACIDS,training_set[n].sequence[i]));
	    training_set[n].composition[a]++;
	  }
      }
      
      for(i=0;i<24;i++) gsl_matrix_set(X,n,i,training_set[n].composition[i]);
      gsl_matrix_set(X,n,24,1); /* to get V0 - the "offset" between runs */
    }

  work=gsl_multifit_linear_alloc(n_training,25);
  gsl_multifit_wlinear(X,w,y,c,cov,&chisq,work);
  gsl_multifit_linear_free(work);


  if(toupper(output_format[0])=='T') /* output as tab-delimited text */
   {
     // printf("\nbest fit to experimental retention data:\n");
     for(i=0;i<24;i++) printf("%c\t%f\n",AMINO_ACIDS[i],gsl_vector_get(c,(i)));
     printf("O\t%f\n\n",gsl_vector_get(c,(24)));
     
     return 0;
   }

  if(toupper(output_format[0])=='C') /* output CSV */
   {
     // printf("\nbest fit to experimental retention data:\n");
     for(i=0;i<24;i++) printf("%c,%f\n",AMINO_ACIDS[i],gsl_vector_get(c,(i)));
     printf("O,%f\n\n",gsl_vector_get(c,(24)));

     return 0;
   }
  
  if(toupper(output_format[0])=='X') /* output XML */
   {
     // printf("\nretenion model in XML structure:\n\n"); /* comment out in deployed versions */

     printf("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
     printf("<rt_model training_file=\"%s\" rt_version=\"4.0\" input_format=\"%s\">\n",infile,input_format);
     for(i=0;i<19;i++) printf(" <retention_coefficient amino_acid=\"%c\" value=\"%f\"/>\n",AMINO_ACIDS[i],gsl_vector_get(c,(i)));
     printf(" <retention_coefficient amino_acid=\"m\" modification=\"oxidation\" value=\"%f\"/>\n",gsl_vector_get(c,(19)));
     for(i=21;i<24;i++) printf(" <retention_coefficient amino_acid=\"%c\" modification=\"phosphorylation\" value=\"%f\"/>\n",AMINO_ACIDS[i],gsl_vector_get(c,(i)));
     printf(" <retention_coefficient amino_acid=\"O\" modification=\"constant offset\" value=\"%f\"/>\n",gsl_vector_get(c,(24)));
     printf("</rt_model>\n");

     return 0;
   }
}
